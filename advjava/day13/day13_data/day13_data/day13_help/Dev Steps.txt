Dev Steps
1. 
Copy n import template 
 - spring_mvc_hibernate

2. Configure Spring supplied Front Controller (to ensure any req coming from any client will be interecepted by this global interceptor - centralized dispatcher)

class - o.s.w.s.DispatcherServlet(D.S) - entry point
who manages its life cycle - WC
web.xml
 - servlet tags
 url-pattern : /
 load-on-startup : 1
 servlet-name : spring
servlet - class - o.s.w.s.DispatcherServlet - (D.S)



3. @ Web app start up - WC starts life cycle of D.S
D.S in it's init()
 - Starts SC (i.e  creates the instance of WebApplicationContext) 
 - using xml config file
 - defaults 
 - name : servletName-servlet.xml(eg - spring-servlet.xml)
 - location : WEB-INF
 - contents : instructions meant for starting SC
 - using these instructions
 - SC creates ,
  -  HandlerMapping bean ( initially empty.)
  -  ViewResolver Bean 
    - loaded with 3 properties
    -prefix : /WEB-INF/views/
    -suffix : .jsp
    - viewClass : JSTLView (to enable JSTL actions in JSP)
 

4. Create request handling controller (Handler)
 - contains Presentation logic(P.L)
 - prog supplied : spring bean(singleton n eager)
   Mandatory annotations
 - @Controller : class level
 - @RequestMapping - method level - mandatory
     (optionally at class level 
      - to specify base url pattern) 
  - for intercepting GET , POST,PUT,DELETE,PACH.... (like service(rq,rs))
  Method level - 
  @RequestMapping 
   OR
  @GetMapping - doGet 
  OR
  @PostMapping - doPost
....

5. Create JSP based view layer
  eg -  index.jsp 
 -  under : WEB-INF/views

6. Test the flow.
Web clnt sends request 
1. http://host:port/ctx_path/
-> D.S -> H.M -> HandlerName+methodName
-> D.S -> calls method
-> rets LVN -> D.S -> LVN -> V.R
-> AVN -> D.S
-> chks for model attributes -> no -> forwards to view layer (index.jsp)


2. After clicking on the link (index.jsp)
<h5>
 <a href="test/test1">Test ModelAndView</a>
</h5>
URL - http://host:port/ctx_path/test/test1
-> D.S -> H.M -> TestController.testModelAndView
-> D.S invokes the method

What is model attribute ?
 - it's server side attribute(key-value pair)
 - created by Handler(prog)
 - Meant for sharing the results(data) between Handler n View layer(JSP)
 - saved under request scope.

Different ways of of adding model attributes
1. Using ModelAndView class
 - It can hold - LVN n model attrbutes.
 - Constructor
 public ModelAndView(String LVN , String modelAttrbuteName,Object modelValue)

Handler creates ModelAndView object and returns it to D.S
-> D.S extracts LVN -> V.R -> AVN
-> D.S -> checks for model attribute/s -> present
-> SC adds model attribute/s under - request scope
-> forwards to JSP
JSP - ${requestScope.attrName}
OR
2. Using o.s.ui.Model interface
 - Holder of model attributes.
 - Simply add this as the method argument of request handling method
 - SC creates it as dependency(IoC) - empty Model map
 - Prog's job 
 - add model attribute
How 
API of Model interface
public Model addAttribute(String attrName,Object attValue);

Handler's method explicitly returns LVN -> D.S
SC implicitly rets model map -> D.S
-> D.S sends -> LVN -> V.R -> AVN -> D.S
SC adds model attribute/s under request scope -> forwards the client to view layer.


Continue with Spring MVC Hibernate integration
Objective - List all available restaurants

Configuration steps
1. web.xml 
 - added D.S entry
2. spring-servlet.xml
 - to start SC in web app
3. import hibernate config file 
 - in spring-servlet.xml

4. name of hibernate config file 
- hibernate-persistence.xml
- location : <resources> (run time classpath)
Contents -
4.1 Configure Apache Supplied Data source bean 
 - to create faster (more  efficient) DBCP

4.2 Configure Spring supplied o.s.orm.hibernate5.LocalSessionFactoryBean
 -to provide SessionFactory
 -It will be used as a dependency in DAO layer
   - using @AutoWired.
 - dependency of LocalSessionFactoryBean
  - Apache Supplied Data source bean (created in earlier step)

4.3 Configute Spring supplied Transaction manager bean
 - o.s.orm.hibernate5.HibernateTransactionManager
 - so that Spring can manage the transactions automatically (reducing boiler   	plate code)

4.4 Enable annotation based transactions
  <tx:annotation-driven/>
   - Using @Transactional annotation.

This completes configuration steps.

Actual dev steps
Controller --> Service --> DAO --> DB

Observation - 
Instead of spending time in config , enter Spring Boot

Objective - Port existing spring_mvc_hibernate with spring boot
 - CRUD with Restaurants

1.Copy n  import 
 - "spring_boot_mvc_template"
 - force update maven project
 - clean compile

2. Configure , application.properties file
 - <resources>
 - add DB properties.(edit db password)

3. Create / copy - spring beans 
 - Controller
 - service
 - dao
 Hibernate managed entities
 - entity

4. Test application

5. Problem 
- Got the exception
 - HibernateException - in sessionFactory.getCurrentSession()
  - mesg : no current session configured.

 Cause - Spring boot does NOT directly support , hibernate native APIs
(eg - Session, SessionFactory ...)

 Solution - replace Hibernate by its abstraction
 - JPA

Steps 
 1. In Dao Layer 
 - Replace the SessionFactory  dependecy  by 
   - jakarta.persistence.EntityManager
   - super interface of hibernate Session.
   - @AutoWired 
     private EntityManager manager;
  - Use EntityManager's API for CRUD operations
   - eg - persist, merge, get,createQuery , remove....

 JPA supports @PersistenceContext annotation also 
  - to auto wire EntityManager
 
 EntityManager is associated with 
  - pooled out DB connection
  - L1 cache (as before !)
