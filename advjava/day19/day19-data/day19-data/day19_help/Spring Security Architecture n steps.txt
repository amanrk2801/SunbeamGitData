Spring Security overview

Spring Security is a powerful and highly customizable authentication and access-control framework. 

It is supplied as a "ready made aspect" , from spring security framework , that can be easily plugged in spring MVC application or RESTful web service.

It is "THE" standard for securing Spring-based applications. Spring Security is a framework that focuses on providing both authentication and authorization to Java applications. 

Like all Spring projects, the real power of Spring Security is found in how easily it can be extended to meet custom requirements.

Features

1. Comprehensive and extensible support for both Authentication and Authorization
2. Protection against attacks like session fixation, clickjacking, cross site request forgery(CSRF), etc..
3.Servlet API integration (Uses Servlet Filter chain)
4.Integration with Spring Web MVC.




Spring Security Architecture

Dev Steps 
1. Add spring security starter dependency in pom.xml
Effect -> all end points - protected (secured) - in accessible
 - Entire spring boot app 
  - under the authentication lock.

2. Defaults offered by  spring security -
- protects all endpoints (including swagger)
- supplies auto generated login n logout pages
  -  to support form login based authentication
  - suitable in MVC web applications

- supports HTTP Basic authentication for REST clients
- suplies default user
 - name : user
 - password - randomly generated by spring security
-  Offers CSRF(Cross Site Request Forgery)  protection
 - Creates HttpSession object , to store spring security context (info)

2.1 Why CSRF protection is NOT required in REST APIs ?
 - CSRF attacker basically uses cookies to forge your requests, to the vulnearable web site.
 - Since in RESTful web service , we will NOT use HttpSession or jsessionid cookie (since its stateless architecture)  , you can disable the CSRF protection.

It's definitely required in monolithic web app using HttpSession.

2.2 Customize spring security , by adding security config class
 - disable CSRF protection
 - session creation policy - stateless
 - disable form login based authentication
 - enable basic authentication scheme , for REST clients
 - replace spring security generated user name (user) n password by custom user name n password.
  - using application.properties file.

2.2 Identify Security requirements for your backend application
 - any one (un protected => permit all ) should be able to access
    swagger ui , user sign in , user sign up , list all available restaurants 
 - only authenticated users
    should be able assign address
 - only user logged in under customer role 
  - should be able to place order
 - only user logged in under admin role 
  - should be able to add food item | update restaurant | delete restaurant


3. Add spring sec user name n password in app properties file , to replace auto generated details.
    -user details are stored in mem.

4. Test end points using 
 - browser - form login
 - postman - basic auth.

4.2 Add Spring security configuration 
 - to disable CSRF protection
(Since CSRF protection is required in - stateful web app n not in stateless REST APIs - where entire state management is done on client side)


5. Authentication was done BUT no authorization!
6. To override defaults -
  - create spring configuration class
  - Annotations 
   - @Configuration
   - @EnableWebSecurity
   - @EnableMethodSecurity
7. Add a Bean (@Bean annotated method) 
 - to supply user details
  - using ready made imple class of UserDetailsService i/f
   - InMemoryUserDetailsManger - class 
    - added user details (name , pwd, Collection<GrantedAuthority> roles)
    - UserDetails - i/f - implemented by User class - spring sec class

8. Add a Bean (@Bean annotated method) 
 - to supply authorization rules, disable form login , disable CSRF ,enable basic auth , disable session ,
 - To return : SecurityFilterChain
 - Depcy (method arg) - HttpSecurity
 - disable CSRF protection (since RESTful web service - stateless)
 - authorized HTTP reqs 
  - permit all
   - swagger ("/v*/api-docs/**","/swagger-ui/**")
   - user siginin , user signup
   - public end points (eg - view products , check available flights...)
  - only authentication (eg - add product to cart)
  - authentication + authorization (eg - add product)
  - disable form login
  - enable basic auth (to be replaced later by JWT - more secure)
  - HTTP session  management - disable HTTP session


Flow 
REST clnt sends a request to REST server 
-> Intercepted by DelegatingFilterProxy
 - It is a Filter class .
 - Acts as bridge between servlet filters n spring beans
 - Delegates all work to a Spring-managed filter bean
  - To springSecurityFilterChain.
-> Spring sec filter chain  takes over 
 -> current filter - BasicAuthenticationFilter
  - Base 64  decoding of username:password
(Basic base64 enc username:password) - req header - "Authorization"
 -> BasicAuthenticationFilter delegates the authentication to AuthenticationManager (i/f) <--- imple by ProviderManager
 -> i.e Filter invokes - public Authentication authenticate(Authentication auth) throws AuthenticationException
 -> Authentication i/f 
  - auth token
  - imple class
  - UserNamePasswordAuthenticationToken
  - Filter creates instance of the UserNamePasswordAuthenticationToken(Object username ,Object password)
  - isAuthenticated : false (=> authentication is not yet done!)

-> AuthMgr iterates through the list of available AuthProviders
 - AuthMgr invokes supports() method
  - rets false - continues 
  - rets true 
   - AuthMgr calls - authenticate(Authentication obj) method of  selected Auth Provider

-> AuthenticationProvider -i/f 
 - imple by DaoAuthenticationProvider (default provider)

->2 Dependencies of AuthenticationProvider
   -1.  PasswordEncoder (i/f) <--- BCryptPasswordEncoder (imple class)
    - supplied by spring sec crypto package
    - to make it available as the dependency
     - configure it as a spring bean (@Bean)
     - in spring application class (main)
    - internally used by DaoAuthenticationProvider 
     - to encrypt (SHA-256 | 512) incoming password
    - 2. UserDetailsService i/f 
     - DaoAuthProvider uses it to fetch user details from either In mem | DB
     - Functional i/f
     - SAM - functional method
      -public UserDetails loadUserByUserName(String userName|email) throws            	UserNameNotFoundException
     
     - UserDetails - i/f 
      - represents actual user details fetched  from DB or memory
      - Methods
        public String getUserName()
	public String getPassword()
        public Collection<? extends GrantedAuthority> getAuthorities()

     -> DaoAuthProvider calls 
       loadUserByUserName(username) of UserDetailsService
       -> in case of success (=> username found)
           - rets UserDetails loaded from mem | db 
           - DaoAuthProvider verifies - pwd
            - tries to match incoming encrypted password  with the pwd stored in 			UserDetails object
            - in case of a match - authentication successfully done ! 
   -> DaoAuthProvider rets verified UserDetails to -> Auth Mgr
     -> It stores verified UserDetails in the Authentication object
        - sets isAuthenticated - true
    -> AuthMgr rets this fully authenticated , 
          Authentication object to BasicAuthFilter 
      - Authentication has - username , pwd : null ,Collection<GrantedAuthority> 

    -> BasicAuthFilter stores Authentication obj under Spring security Context

   -> Next important  filter AuthorizationFilter
     -> Extracts Granted Authorities from Spring security Context
           n performs role based authorization. 

    ->in case of complete success ->delegates the request to D.S (Front controller)
 
   -> In case of Authentication failure (AuthenticationException)
 -> Spring sec aborts the req processing -> sends SC 401 to the clnt
   ->  In case of Authorization failure (AuthorizationException)
 -> aborts the req processing -> sends SC 403 to the clnt


 
Next Dev steps (project - day18.2)
 Replace In mem user details service  by DB based auth.
 BUT will still use BasicAuth

1. Remove UserDetailsService bean form spring config file
2. Create custom imple class for - UserDetailsService
3. imple the method - loadUserByUserName
4. UserEntity implements - UserDetails
5. UserDao 
 - finder method - findByEmail
6. Test it !
 - test user signup (with enc pwd)
 - user sign in 
  - use postman client (Basic auth - username:pwd)

eg - {
  "firstName": "Rama",
  "lastName": "Patil",
  "email": "rama@gmail.com",
  "password": "ram#1234",
  "subscriptionAmount": 2000,
  "userRole": "ROLE_CUSTOMER",
  "dob": "1999-07-04"
}


{
  "firstName": "Mihir",
  "lastName": "Sengupta",
  "email": "mihir@gmail.com",
  "password": "xyz$1234",
  "dob": "1992-05-14",
  "userRole": "ROLE_ADMIN",
   "subscriptionAmount" : 1500
}


Instead of using postman 
 - configure Authorization header from Swagger
- Create separate Swagger configuration class 
- Add swagger annotations

@SecurityScheme(
        name = "basicAuth",
        type = SecuritySchemeType.HTTP,
        scheme = "basic"
)

// JWT BEARER TOKEN AUTH
//@SecurityScheme(
//        name = "bearerAuth",
//        type = SecuritySchemeType.HTTP,
//        scheme = "bearer",
//        bearerFormat = "JWT"
//)

@OpenAPIDefinition(info = @Info(title = "Food Delivery API", version = "v1.0"), security = {
		
		@SecurityRequirement(name = "basicAuth") })
@Configuration
public class SwaggerConfig {
}

Test it !


Next Objective - Replace Basic Auth mechanism by JWT (project day18.3)
(Json Web Token)
Refer - jwt.io

Dev steps 
1. Copy from earlier basic auth sec project
1.1 Remove Basic Auth support
 - from spring sec config class.

1.2 Add JWT dependencies , 
 To create n later validate token.
 - jjwt api
 - jjwt impl
 - jjwt jackson

2. Create new end point in UserController
 user sign in
  URL - http://host:port/users/signin
  Method - POST
  Payload - DTO (email n pwd)
  - success  Auth Resp - message  +signed JWT
  - failed - SC 401 => authentication failed 

2.1 In user sign in 
 - Simply call AuthenticationManager's authenticate method
  - Configure AuthenticationManager as a spring bean 
   - in spring sec config class
 - authenticate
    i/p - Authentication <- UserNamePasswordAuthToken (em,pass)
    o/p - throws exc | fully populated Auth object (em,pwd - null, granted authorities)
   -> simply add it to JWT 
    
   -> generate token.
   -> sends signed jwt to the clnt 

3. JWT token generation steps
3.1 Add JJWT dependencies in pom.xml
 -
3.2 Add 2 custom properties in application.properties file
      - JWT expiration time (in msec)
      - secret key (256 bit min - SHA256)

Refer - https://generate-random.org/encryption-key-generator

3.3 Create (copy) 
 - JWT Utils for the token generation
  - create token (to be used in sign in) 
  - validate token (to be used custom JWT filter)

3.4 Test User sign in endpoint (in swagger)
 - in case of successful auth 
 - JWT should be seen in response.

--------------------------Done so far --------------------------------

4. In JS client (eg React Client)
 - store this token in local | session storage.
 - Any time clnt is making a request to the secured end point ,
  send this token (using React Interceptor) , in Authorization header 
-> to the server.


5. Create custom JWT filter 
 -  to intercept every incoming request
 - validate token
 - extract authentication object (JWT claims) 
  - in case of success - 
   - store valid auth object under Spring Sec ctx.

6. Add jwt filter before 
 UserNamePasswordAuthenticationFilter
 - in spring sec config class.

7. Test it !
 - postman 
(Use Auth - Bearer Token 
 paste - JWT token )
 Test secured end points for
  - authentication
  - role based authorization.

8. Problem Observed 
- In case client wants to access protected end point , but doesn't send any JWT 
- what should be error code ?
 - SC 401 | SC 403

9. To solve this error 
- Add a class - JwtAuthEntryPoint
 -  implements AuthenticationEntryPoint 
 - configure it as spring bean.
  - implement method 
   - public void commence(HttpServletRequest request,
                         HttpServletResponse response,
                         AuthenticationException authException) throws IOException {
     - send error response.
         
10. To Handle unauthenticated access with 401
- add in spring sec config class  , security filter chain 
 - http.exceptionHandling(ex -> ex.authenticationEntryPoint(jwtAuthEntryPoint));

